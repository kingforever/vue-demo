<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <style></style>

  <body>
    <script>
      let activeEffect;
      //effect栈
      const effectStack = [];
      const jobQueue = new Set();
      const p = Promise.resolve();
      const ITERATE_KEY = Symbol();
      const MAP_KEY_ITERATE_KEY = Symbol()
      const bucket = new WeakMap();
      const reactiveMap = new Map();
      const originMethod = Array.prototype.includes;
      const mutableInstrumentations = {
        add(key) {
          const target = this.raw;
          const hasKey = target.has(key);
          const res = target.add(key);
          if (!hasKey) {
            trigger(target, key, "ADD");
          }
          return res;
        },
        delete(key) {
          const target = this.raw;
          const hasKey = target.has(key);
          const res = target.delete(key);
          if (hasKey) {
            trigger(target, key, "DELETE");
          }
          return res;
        },
        get(key) {
          const target = this.raw;
          const hasKey = target.has(key);
          track(target, key);
          if (hasKey) {
            const res = target.get(key);
            return typeof res === "object" ? reactive(res) : res;
          }
        },
        set(key, value) {
          const target = this.raw;
          const hasKey = target.has(key);
          const oldVal = target.get(key);
          target.set(key, value.raw || value);
          if (!hasKey) {
            trigger(target, key, "ADD");
          } else if (
            oldVal !== value ||
            (oldVal === oldVal && value === value)
          ) {
            trigger(target, key, "SET");
          }
        },
        //处理Map的forEach方法
        forEach(cb, thisArg) {
          const target = this.raw;
          const wrap = (val) =>
            typeof val === "object" && val !== null ? reactive(val) : val;
          track(target, ITERATE_KEY);
          target.forEach((val, key) => {
            cb.call(thisArg, wrap(val), wrap(key), this);
          });
        },
        [Symbol.iterator]:iterationMethod,
        entries: iterationMethod,
        values: valuesIterationMethod,
        keys: keysIterationMethod
      };
      function iterationMethod() {
        const target = this.raw;
        const itr = target[Symbol.iterator]();
        const wrap = (val) =>
          typeof val === "object" && val !== null ? reactive(val) : val;
        track(target, ITERATE_KEY);
        return {
          next() {
            const { value, done } = itr.next();
            return {
              value: value ? [wrap(value[0]), wrap(value[1])] : value,
              done,
            };
          },
          [Symbol.iterator]() {
            return this
          }
        };
      }
      function valuesIterationMethod() {
        const target = this.raw;
        const itr = target.values();
        const wrap = (val) =>
          typeof val === "object" && val !== null ? reactive(val) : val;
        track(target, ITERATE_KEY);
        return {
          next() {
            const { value, done } = itr.next();
            return {
              value: wrap(value),
              done,
            };
          },
          [Symbol.iterator]() {
            return this
          }
        };
      }
      function keysIterationMethod() {
        const target = this.raw;
        const itr = target.keys();
        const wrap = (val) =>
          typeof val === "object" && val !== null ? reactive(val) : val;
        track(target, MAP_KEY_ITERATE_KEY);
        return {
          next() {
            const { value, done } = itr.next();
            return {
              value: wrap(value),
              done,
            };
          },
          [Symbol.iterator]() {
            return this
          }
        };
      }
      //一个标记变量，代表是否进行追踪，默认值为true，即允许追踪
      let shouldTrack = true;
      const arrayInstrumentations = {};
      ["push", "pop", "shift", "unshif", "splice"].forEach((method) => {
        const originMethod = Array.prototype[method];
        arrayInstrumentations[method] = function (...args) {
          shouldTrack = false;
          let res = originMethod.apply(this, args);
          shouldTrack = true;
          return res;
        };
      });
      ["includes", "indexOf", "lastIndexOf"].forEach((method) => {
        const originMethod = Array.prototype[method];
        arrayInstrumentations[method] = function (...args) {
          let res = originMethod.apply(this, args);
          if (res === false || res === -1) {
            res = originMethod.apply(this.raw, args);
          }
          return res;
        };
      });
      let isFlushing = false;
      function flushJob() {
        if (isFlushing) {
          return;
        }
        isFlushing = true;
        p.then(() => {
          jobQueue.forEach((job) => {
            job();
          });
        }).finally(() => {
          isFlushing = false;
        });
      }
      function reactive(obj) {
        const existionProxy = reactiveMap.get(obj);
        if (existionProxy) {
          return existionProxy;
        }
        const proxy = createReactive(obj);
        reactiveMap.set(obj, proxy);
        return proxy;
      }
      function shallowReactive(obj) {
        return createReactive(obj, true);
      }
      function readonly(obj) {
        return createReactive(obj, false, true);
      }
      function shallowReadonly(obj) {
        return createReactive(obj, true, true);
      }
      // function createReactive(obj, isShallow = false, isReadonly = false) {
      //   return new Proxy(obj, {
      //     get(target, key, receiver) {
      //       // console.log(receiver)
      //       //代理对可以通过row属性访问原始属性
      //       if (key === "raw") {
      //         return target;
      //       }
      //       if (key === 'size') {
      //         return Reflect.get(target, key, target)
      //       }
      //       if (Array.isArray(target) && arrayInstrumentations.hasOwnProperty(key)) {
      //         return Reflect.get(arrayInstrumentations, key, receiver)
      //       }
      //       if (!isReadonly && typeof key !== 'symbol') {
      //         track(target, key)
      //       }
      //       const res = Reflect.get(target, key, receiver)
      //       if (isShallow) {
      //         return res;
      //       }
      //       if (typeof res === 'object' && res !== null) {
      //         //调用reactive将结果包装成响应式数据并返回
      //         return isReadonly ? readonly(res) : reactive(res)
      //       }
      //       return res
      //     },
      //     set(target, key, newVal, receiver) {
      //       //如果是只读打印警告信息并返回
      //       if (isReadonly) {
      //         console.warn(`属性${key}是只读的`);
      //         return true;
      //       }

      //       const oldVal = target[key];
      //       const type = Array.isArray(target) ? Number(key) < target.length ? 'SET' : 'ADD' : Object.prototype.hasOwnProperty.call(target, key)
      //         ? "SET"
      //         : "ADD";
      //       const res = Reflect.set(target, key, newVal, receiver);
      //       // target === receiver.raw 说明receiver就是target的代理对象
      //       if (target === receiver.raw) {
      //         if (
      //           oldVal != newVal &&
      //           (oldVal === oldVal || newVal === newVal)
      //         ) {
      //           trigger(target, key, type, newVal);
      //         }
      //       }
      //       return res;
      //     },
      //     // in 操作符
      //     has(target, key) {
      //       console.log("1233");
      //       track(target, key);
      //       return Reflect.get(target, key);
      //     },
      //     //删除属性
      //     deleteProperty(target, key) {
      //       if (isReadonly) {
      //         console.warn(`属性${key}是只读的`);
      //         return true;
      //       }
      //       const hadKey = Object.prototype.hasOwnProperty.call(target, key);
      //       const res = Reflect.deleteProperty(target, key);
      //       if (res && hadKey) {
      //         trigger(target, key, "DELETE");
      //       }
      //       return res;
      //     },
      //     //for in 循环
      //     ownKeys(target) {
      //       //如果操作目标对象target是数组，则使用length属性作为key并建立响应联系
      //       track(target, Array.isArray(target) ? 'length':ITERATE_KEY);
      //       return Reflect.ownKeys(target);
      //     },
      //   });
      // }
      //代理set和map
      function createReactive(obj, isShallow = false, isReadonly = false) {
        return new Proxy(obj, {
          get(target, key, receiver) {
            if (key === "size") {
              track(target, ITERATE_KEY);
              return Reflect.get(target, key, target);
            }
            if (key === "raw") {
              return target;
            }
            return mutableInstrumentations[key];
          },
        });
      }
      function track(target, key) {
        if (!activeEffect || !shouldTrack) return;
        let depsMap = bucket.get(target);
        if (!depsMap) {
          bucket.set(target, (depsMap = new Map()));
        }
        let deps = depsMap.get(key);
        if (!deps) {
          depsMap.set(key, (deps = new Set()));
        }
        deps.add(activeEffect);
        activeEffect.deps.push(deps);
      }
      function trigger(target, key, type, newVal) {
        let depsMap = bucket.get(target);
        if (!depsMap) {
          return;
        }
        const effectsToRun = new Set();
        const effects = depsMap.get(key);
        //修改了数组的length属性，需要把索引大于或等于新的length值的元素取出并添加到effectsToRun中待执行
        if (Array.isArray(target) && key === "length") {
          depsMap.forEach((effects, key) => {
            if (key >= newVal) {
              effects.forEach((effectFn) => {
                if (effectFn !== activeEffect) {
                  effectsToRun.add(effectFn);
                }
              });
            }
          });
        }
        effects &&
          effects.forEach((effectFn) => {
            if (effectFn !== activeEffect) {
              effectsToRun.add(effectFn);
            }
          });
        //将这些副作用函数添加到effectsToRun中，待执行
        if (type === "ADD" && Array.isArray(target)) {
          const lengthEffects = depsMap.get("length");
          lengthEffects &&
            lengthEffects.forEach((effectFn) => {
              if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn);
              }
            });
        }
        if (( type === "ADD" ||
          type === "DELETE") &&  Object.prototype.toString.call(target) === "[object Map]") {
            const iterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY);
          iterateEffects &&
            iterateEffects.forEach((effectFn) => {
              if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn);
              }
            });
          }
        if (
          type === "ADD" ||
          type === "DELETE" ||
          (type === "SET" &&
          Object.prototype.toString.call(target) === "[object Map]")
        ) {
          const iterateEffects = depsMap.get(ITERATE_KEY);
          iterateEffects &&
            iterateEffects.forEach((effectFn) => {
              if (effectFn !== activeEffect) {
                effectsToRun.add(effectFn);
              }
            });
        }
        effectsToRun.forEach((effectFn) => {
          if (effectFn.options.scheduler) {
            effectFn.options.scheduler(effectFn);
          } else {
            effectFn();
          }
        });
      }
      function cleanup(effectFn) {
        for (let i = 0; i < effectFn.deps.length; i++) {
          const deps = effectFn.deps[i];
          deps.delete(effectFn);
        }
        effectFn.deps.length = 0;
      }
      function effect(fn, options = {}) {
        const effectFn = () => {
          cleanup(effectFn);
          activeEffect = effectFn;
          effectStack.push(activeEffect);
          const res = fn();
          effectStack.pop();
          activeEffect = effectStack[effectStack.length - 1];
          return res;
        };
        effectFn.deps = [];
        effectFn.options = options;
        if (effectFn.options.lazy) {
          return effectFn;
        }
        effectFn();
      }
      //计算属性
      function computed(getter) {
        let dirty = true;
        let value;
        const effectFn = effect(getter, {
          lazy: true,
          scheduler() {
            if (!dirty) {
              dirty = true;
              trigger(obj, "value");
            }
          },
        });
        const obj = {
          get value() {
            if (dirty) {
              value = effectFn();
              dirty = false;
            }
            track(obj, "value");
            return value;
          },
        };

        return obj;
      }
      function traverse(value, seen = new Set()) {
        if (typeof value !== "object" || value === null || seen.has(value))
          return;
        seen.add(value);
        for (const key in value) {
          traverse(value[key], seen);
        }
        return value;
      }
      //watch函数
      function watch(source, cb, options = {}) {
        let getter;
        if (typeof source === "function") {
          getter = source;
        } else {
          getter = () => traverse(source);
        }
        let oldValue, newValue;
        let cleanup;
        function onInvalidate(fn) {
          cleanup = fn;
        }
        const job = () => {
          newValue = effectFn();
          //在调用回调函数cb之前，先调用过期回调
          if (cleanup) {
            cleanup();
          }
          cb(newValue, oldValue, onInvalidate);
          oldValue = newValue;
        };
        let effectFn = effect(getter, {
          lazy: true,
          scheduler: () => {
            if (options.flush === "post") {
              const p = Promise.resolve();
              p.then(job);
            } else {
              job();
            }
          },
        });
        if (options.immediate) {
          job();
        } else {
          oldValue = effectFn();
        }
      }

      const p1 = reactive(
        new Map([
          ["key1", "value1"],
          ["key2", "value2"],
        ])
      );
      effect(() => {
        for (const key of p1.keys()) {
          console.log(key, 459)
        }
      });
      p1.set("key2", "value3");
    </script>
  </body>
</html>
